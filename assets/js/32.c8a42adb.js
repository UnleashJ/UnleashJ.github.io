(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{598:function(t,s,a){"use strict";a.r(s);var n=a(16),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("  在日常开发中，使用async/await处理异步HTTP请求的代码随处可见，由于类似同步代码的书写方式，使得这类代码非常容易理解和推断出它的逻辑。为了弄清楚async/await真正的用法及原理，掌握和理解期约变得尤为重要。")]),t._v(" "),a("p",[t._v("（学习参考：JavaScript权威指南。本章节中，上来并没有介绍怎么创建期约，而是直接使用现有的可以返回期约的API--fetch，然后讲解期约的用法以及开发中需要注意的事项。随后才介绍了如何使用Promise构造函数创建期约。）")]),t._v(" "),a("h2",{attrs:{id:"期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#期约"}},[t._v("#")]),t._v(" 期约")]),t._v(" "),a("p",[t._v("  期约是一种处理回调的不同方式，它返回一个期约对象，我们可以在这个期约对象上注册一个或多个回调函数。异步计算完成时，他们会被调用。期约相较于以往使用回调的异步编程，有以下特点：")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("期约可以让多层嵌套回调以一种线性的期约链的形式表现，更容易阅读和理解。")]),t._v(" "),a("li",[t._v("传统回调当异步函数抛出异常，无法将异常传递到异步操作的发起者。期约标准化了异步错误处理，可以让错误正确传播。")]),t._v(" "),a("li",[t._v("不能使用期约表示重复的异步计算。例如可以使用期约代替setTimeout()，但是不能使用期约代替setInterval()。可以使用期约代替ajax请求，但是不能使用期约代替DOM中的点击事件，因为这个事件允许用户多次触发。")])])]),t._v(" "),a("h3",{attrs:{id:"使用期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用期约"}},[t._v("#")]),t._v(" 使用期约")]),t._v(" "),a("p",[t._v("  期约返回一个期约对象，这个期约对象有一个实例方法then()，可以接受两个回调函数作为参数。期约落定时，调用第一个回调函数处理结果。第二个回调函数表示期约出现错误时的异常处理。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("可以把then()想象成addEventListener()")])]),a("p",[t._v("  同步计算在正常结束收会把计算结果返回给调用者；基于期约的异步计算把计算结果返回给作为then()的第一个参数的回调函数。同步计算出错时，异常会沿着调用栈向上一直传播到一个处理它的catch块中；而基于期约的异步计算在运行时，它的调用者已经不在调用栈，所以出错时，把异常传给作为then()的第二个参数的回调函数。下面是一个基于期约的异步计算的例子，getJson()是一个HTTP请求，返回一个期约对象：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getJson")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api/xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("handleResult"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("handleError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleResult")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("data")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleError")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在实际开发中，不只是getJson会出错，handleResult中也有可能出错，因此上面这个例子中的异常处理方式并不常用。真正常用的是下面这种处理方式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getJson")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api/xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("handleResult"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("handleError"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[a("code",[t._v("catch(handleError)")]),t._v("其实就是"),a("code",[t._v("then(null,handleError)")]),t._v("的一种简写形式。")]),t._v(" "),a("h3",{attrs:{id:"期约链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#期约链"}},[t._v("#")]),t._v(" 期约链")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getJson")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api/xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("  在像上面这样写"),a("code",[t._v(".then()")]),t._v("调用链时，并不会在同一个期约对象上绑定多个回调，而是每一个then()都会返回一个新的期约对象，这个新的期约对象在传给then()的函数执行结束后才会兑现。")]),t._v(" "),a("p",[t._v("  接下来介绍一下“解决”状态的含义，我们知道期约有三种状态：兑现、拒绝、待定。如果c返回的v是一个非期约值，那么p会立即以这个值兑现。如果v是一个期约值，那么p会得到解决但并未兑现。当v兑现时，p会以相同的值兑现，当v拒绝时，p会以相同的里有拒绝。“解决”的含义是当一个期约与另一个期约发生了关联，此时并不知道p将会兑现还是被拒绝，因此说p得到了解决。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getJson")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api/xxx'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("c")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//一些逻辑")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" v\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("  同步代码出错时候，我们会这样描述：沿着调用栈向上冒泡，直到碰到一个catch块。异步期约链，可以这样描述：沿着期约链向下流淌，直到碰到一个catch()调用。")]),t._v(" "),a("p",[t._v("  可以在期约链中间插入一个.catch()来处理那些可以恢复的错误，此时catch可以返回一个正常值，这样就会停止错误传播，继续后续环节的代码执行。")]),t._v(" "),a("h3",{attrs:{id:"并行期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行期约"}},[t._v("#")]),t._v(" 并行期约")]),t._v(" "),a("p",[t._v("  期约链是顺序运行的一个异步操作，并行执行多个异步操作有以下几种方法。")]),t._v(" "),a("p",[a("code",[t._v("Promise.all()")]),t._v("，它接收一个期约对象的数组作为参数，返回一个期约。当输入期约中任意一个拒绝时，返回的期约也将拒绝，并立即返回；否则，返回的期约会以每个输入期约兑现值的数组兑现。若输入数组中，某一个元素不是期约对象，那么他会当成一个已兑现的期约值，并直接复制到输出数组中。")]),t._v(" "),a("p",[a("code",[t._v("Promise.allSettled()")]),t._v("，接收参数与"),a("code",[t._v("Promise.all()")]),t._v("一样，但是它永远不会拒绝返回的期约，而是等待所有输入期约全部落定后兑现（即返回值只有兑现，没有拒绝）。返回的期约解决为一个对象数组，每个对象对应一个输入期约，包含status属性，value/reason属性（输入期约兑现或拒绝）。")]),t._v(" "),a("p",[a("code",[t._v("Promise.race()")]),t._v("同样接收一个期约数组，返回一个期约，这个返回期约会在输入数组中，有一个期约兑现和拒绝时马上兑现或拒绝（有点像竞速）。如果输入数组中有非期约值，则直接返回其中第一个非期约值。")]),t._v(" "),a("h3",{attrs:{id:"创建期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建期约"}},[t._v("#")]),t._v(" 创建期约")]),t._v(" "),a("h4",{attrs:{id:"基于其他期约的期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于其他期约的期约"}},[t._v("#")]),t._v(" 基于其他期约的期约")]),t._v(" "),a("p",[t._v("  给定一个期约，调用"),a("code",[t._v(".then()")]),t._v("就可以创建一个新的期约。")]),t._v(" "),a("h4",{attrs:{id:"基于同步值的期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于同步值的期约"}},[t._v("#")]),t._v(" 基于同步值的期约")]),t._v(" "),a("p",[a("code",[t._v("Promise.resolve()")]),t._v("接受一个值作为参数，并返回一个立即（但异步）以该值兑现的期约。"),a("code",[t._v("Promise.reject()")]),t._v("，也接收一个参数，但返回一个以该参数为理由拒绝的期约。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("这两个值返回的期约在被返回时并未兑现或拒绝，但他们会在当前同步代码块运行结束后立即兑现或拒绝。")])]),a("p",[t._v("如果给"),a("code",[t._v("Promise.resolve()")]),t._v("传入一个期约值p1，会返回一个新的期约p2，p2会立即解决，但是要等到p1兑现或拒绝的时候才会被兑现或拒绝。")]),t._v(" "),a("h4",{attrs:{id:"从头开始创建期约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从头开始创建期约"}},[t._v("#")]),t._v(" 从头开始创建期约")]),t._v(" "),a("p",[t._v("  使用Promise()构造函数创建一个新的期约对象，具体用法不在介绍，请参见下面的例子。调用wait会同步调用执行器中的代码，通过resolve解决或兑现返回的期约，通过reject拒绝期约。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("wait")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("duration")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("duration "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'message'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("duration"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//没有给resolve传参数，新期约以undefined值兑现")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"串行期约的两种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#串行期约的两种方式"}},[t._v("#")]),t._v(" 串行期约的两种方式")]),t._v(" "),a("p",[t._v("  期约链的串行需要提前写好整个期约链，有些情况需要动态构建期约链，有两种方式，一种类似构造“多米诺骨牌”形式的期约链，另一种类似于构造“俄罗斯套娃”形式的期约链。")]),t._v(" "),a("h2",{attrs:{id:"async和await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async和await"}},[t._v("#")]),t._v(" async和await")]),t._v(" "),a("p",[t._v("  这两个关键字让代码向同步代码一样容易理解和推理。await关键字接收一个期约并将其转换为一个返回值或抛出一个异常。即如果p兑现，那么"),a("code",[t._v("await p")]),t._v("的值就是兑现p的值。如果p被拒绝，那么"),a("code",[t._v("await p")]),t._v("表达式就会抛出拒绝p的值。async返回一个期约对象，await只能用在async关键字声明的函数中。")]),t._v(" "),a("p",[t._v("  技巧：等候多个期约时，如果我们像第一种方式那么写，意味着必须等p1返回的期约兑现之后才会开始执行p2获取期约。如果p1与p2是两个毫无依赖关系的期约，那么这样做无疑是浪费性能。可以利用Promise.all()并行执行这两个异步操作。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//方式一，浪费性能")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" value1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" value2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//方式二，并行执行")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("value1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("value2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" Promise"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("all")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("p2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);